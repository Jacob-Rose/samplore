#!/usr/bin/env python3
"""
Samplore Windows Cross-Compilation Script
Compiles Samplore for Windows from Linux using MinGW-w64
"""

import argparse
import os
import platform
import shutil
import subprocess
import sys
from pathlib import Path


SCRIPT_DIR = Path(__file__).parent.resolve()
PROJECT_ROOT = SCRIPT_DIR.parent
BUILDS_DIR = PROJECT_ROOT / "Builds"
ENV_FILE = PROJECT_ROOT / ".env"


def load_env_file():
    """Load environment variables from .env file."""
    if not ENV_FILE.exists():
        return {}
    
    env_vars = {}
    with open(ENV_FILE, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            if '=' in line:
                key, value = line.split('=', 1)
                env_vars[key.strip()] = value.strip()
    
    return env_vars


def check_mingw_dependencies():
    """Check if MinGW cross-compiler is installed."""
    print("Checking MinGW cross-compiler dependencies...")
    
    required_tools = [
        "x86_64-w64-mingw32-g++",
        "x86_64-w64-mingw32-gcc",
        "x86_64-w64-mingw32-windres",
        "x86_64-w64-mingw32-strip"
    ]
    
    missing = []
    for tool in required_tools:
        if not shutil.which(tool):
            missing.append(tool)
    
    if missing:
        print("✗ Missing MinGW tools:")
        for tool in missing:
            print(f"  - {tool}")
        print()
        print("Install with:")
        print("  sudo apt-get install mingw-w64")
        print()
        return False
    
    print("✓ All MinGW tools found")
    return True


def generate_windows_build():
    """Generate Windows build files using Projucer."""
    print("Generating Windows build files...")
    
    # Load environment
    env_vars = load_env_file()
    juce_path = env_vars.get('JUCE_PATH')
    
    if not juce_path:
        print("✗ JUCE_PATH not configured in .env")
        return False
    
    # Run configure script to update .jucer and generate builds
    try:
        result = subprocess.run(
            [sys.executable, str(SCRIPT_DIR / "configure.py")],
            check=True,
            capture_output=True,
            text=True
        )
        print("✓ Windows build files generated")
        return True
    except subprocess.CalledProcessError as e:
        print(f"✗ Failed to generate build files: {e}")
        if e.stderr:
            print("Error output:")
            print(e.stderr)
        return False


def build_windows_cross(config="Release"):
    """Build Windows executable using MinGW cross-compiler."""
    print(f"Building Windows executable ({config})...")
    
    # Load environment
    env_vars = load_env_file()
    juce_path = env_vars.get('JUCE_PATH')
    
    if not juce_path:
        print("✗ JUCE_PATH not configured in .env")
        return False
    
    # Check for VisualStudio build directory
    vs2022_dir = BUILDS_DIR / "VisualStudio2022"
    vs2019_dir = BUILDS_DIR / "VisualStudio2019"
    
    build_dir = None
    if vs2022_dir.exists():
        build_dir = vs2022_dir
    elif vs2019_dir.exists():
        build_dir = vs2019_dir
    else:
        print("✗ No VisualStudio build directory found")
        print("Run configure.py first to generate build files")
        return False
    
    # Create a custom Makefile for cross-compilation
    cross_makefile = build_dir / "Makefile.cross"
    print(f"Creating cross-compilation Makefile...")
    
    makefile_content = f"""# Samplore Windows Cross-Compilation Makefile
# Generated by cross-compile-windows.py

# Configuration
CONFIG = {config}
TARGET = Samplore.exe
BUILD_DIR = build/$(CONFIG)/App

# MinGW cross-compiler
CC = x86_64-w64-mingw32-gcc
CXX = x86_64-w64-mingw32-g++
WINDRES = x86_64-w64-mingw32-windres
STRIP = x86_64-w64-mingw32-strip

# JUCE paths
JUCE_MODULES_PATH = {juce_path}/modules
JUCE_LIBPATH = $(JUCE_MODULES_PATH)/../lib
JUCE_INCLUDEPATH = $(JUCE_MODULES_PATH)

# Compiler flags
CXXFLAGS = -std=c++17 -O2 -DJUCE_APP_VERSION=0x900 -DJUCE_DISPLAY_SPLASH_SCREEN=1
CXXFLAGS += -DJUCE_WEB_BROWSER=0 -DJUCE_USE_CURL=1 -DJUCE_USE_FREETYPE=1
CXXFLAGS += -I$(JUCE_INCLUDEPATH) -I../../JuceLibraryCode -I../../Source
CXXFLAGS += -DLINUX=1 -DJUCER_LINUX_MAKE_6D53C8B4=1

# Linker flags
LDFLAGS = -static-libgcc -static-libstdc++
LDFLAGS += -ljuce_audio_basics -ljuce_audio_devices -ljuce_audio_formats
LDFLAGS += -ljuce_audio_processors -ljuce_audio_utils -ljuce_core
LDFLAGS += -ljuce_cryptography -ljuce_data_structures -ljuce_events
LDFLAGS += -ljuce_graphics -ljuce_gui_basics -ljuce_gui_extra
LDFLAGS += -ljuce_opengl -ljuce_product_unlocking -ljuce_video
LDFLAGS += -lfreetype -lpthread -lX11 -lXext -lXinerama -lXcursor -lXrandr
LDFLAGS += -lGL -lGLU -lasound -lcurl

# Source files (you may need to update this list)
SOURCES = ../../Source/Main.cpp \\
          ../../Source/SamplifyMainComponent.cpp \\
          ../../Source/SamplifyMenuBar.cpp \\
          ../../Source/SamplifyProperties.cpp \\
          ../../Source/SamplifyLookAndFeel.cpp \\
          ../../Source/AudioPlayer.cpp \\
          ../../Source/Sample.cpp \\
          ../../Source/SampleLibrary.cpp \\
          ../../Source/SampleDirectory.cpp \\
          ../../Source/SampleAudioThumbnail.cpp \\
          ../../Source/SampleExplorer.cpp \\
          ../../Source/SampleContainer.cpp \\
          ../../Source/SampleTile.cpp \\
          ../../Source/DirectoryExplorer.cpp \\
          ../../Source/DirectoryExplorerTreeViewItem.cpp \\
          ../../Source/FilterExplorer.cpp \\
          ../../Source/TagExplorer.cpp \\
          ../../Source/TagContainer.cpp \\
          ../../Source/TagTile.cpp \\
          ../../Source/TagExplorer_V2.cpp \\
          ../../Source/TagDrawer.cpp \\
          ../../Source/SamplePlayerComponent.cpp \\
          ../../Source/PreferenceWindow.cpp \\
          ../../Source/InfoWindow.cpp \\
          ../../Source/ServerAuthStatus.cpp \\
          ../../Source/ServerAuthUnlockComponent.cpp \\
          ../../Source/ThemeManager.cpp \\
          ../../Source/UI/IconLibrary.cpp \\
          ../../Source/Animation/AnimationManager.cpp

# Object files
OBJECTS = $(SOURCES:.cpp=.o)

# Default target
all: $(BUILD_DIR)/$(TARGET)

# Create build directory
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

# Link executable
$(BUILD_DIR)/$(TARGET): $(OBJECTS) | $(BUILD_DIR)
	$(CXX) $(OBJECTS) -o $@ $(LDFLAGS)
	$(STRIP) $@
	@echo "✓ Windows executable built: $@"

# Compile source files
%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Clean
clean:
	rm -rf $(BUILD_DIR)
	rm -f $(OBJECTS)

.PHONY: all clean
"""
    
    with open(cross_makefile, 'w') as f:
        f.write(makefile_content)
    
    print(f"✓ Cross-compilation Makefile created: {cross_makefile}")
    
    # Build using the cross-compiler
    try:
        print("Starting cross-compilation...")
        subprocess.run(
            ["make", "-f", "Makefile.cross", "all"],
            cwd=build_dir,
            check=True
        )
        
        exe_path = build_dir / "build" / config / "App" / "Samplore.exe"
        if exe_path.exists():
            print(f"✓ Windows executable built successfully!")
            print(f"  Location: {exe_path}")
            print(f"  Size: {exe_path.stat().st_size / 1024 / 1024:.1f} MB")
            return True
        else:
            print("✗ Build completed but executable not found")
            return False
            
    except subprocess.CalledProcessError as e:
        print(f"✗ Cross-compilation failed: {e}")
        return False


def main():
    parser = argparse.ArgumentParser(
        description="Samplore Windows Cross-Compilation Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python3 scripts/cross-compile-windows.py              # Build Release
  python3 scripts/cross-compile-windows.py --config Debug # Build Debug
  python3 scripts/cross-compile-windows.py --check-deps  # Check dependencies only
        """
    )
    
    parser.add_argument(
        "--config",
        choices=["Debug", "Release"],
        default="Release",
        help="Build configuration (default: Release)"
    )
    
    parser.add_argument(
        "--check-deps",
        action="store_true",
        help="Check for cross-compilation dependencies only"
    )
    
    parser.add_argument(
        "--skip-generate",
        action="store_true",
        help="Skip build file generation"
    )
    
    args = parser.parse_args()
    
    print("=" * 70)
    print("Samplore Windows Cross-Compilation")
    print("=" * 70)
    print()
    
    # Check dependencies
    if not check_mingw_dependencies():
        return 1
    
    if args.check_deps:
        print()
        print("Dependencies check complete!")
        return 0
    
    # Generate build files
    if not args.skip_generate:
        if not generate_windows_build():
            return 1
    
    # Cross-compile
    if not build_windows_cross(args.config):
        return 1
    
    print()
    print("=" * 70)
    print("Cross-compilation complete!")
    print("=" * 70)
    print()
    print("To test the Windows executable:")
    print("  1. Copy to Windows machine")
    print("  2. Run Samplore.exe")
    print("  3. Install required Windows dependencies if needed")
    print()
    
    return 0


if __name__ == "__main__":
    sys.exit(main())